/*	$Id$ */
/*
 * Copyright (c) 2017 Kristaps Dzonsons <kristaps@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/queue.h>

#if HAVE_ERR
# include <err.h>
#endif
#include <stdio.h>
#include <stdlib.h>

#include "extern.h"

static	const char *const ftypes[FTYPE__MAX] = {
	"int64_t",
	"const char *",
	NULL,
};

/*
 * Generate the C API for a given field.
 */
static void
gen_strct_field(const struct field *p)
{

	gen_comment(p->doc, 1, "/*", " * ", " */");

	switch (p->type) {
	case (FTYPE_STRUCT):
		printf("\tstruct %s %s;\n", 
			p->ref->tstrct, p->name);
		break;
	case (FTYPE_INT):
		printf("\tint64_t %s;\n", p->name);
		break;
	case (FTYPE_TEXT):
		printf("\tchar *%s;\n", p->name);
		break;
	default:
		break;
	}
}

/*
 * Generate the C API for a given structure.
 */
static void
gen_strct_structs(const struct strct *p)
{
	const struct field *f;

	gen_comment(p->doc, 0, "/*", " * ", " */");

	printf("struct\t%s {\n", p->name);
	TAILQ_FOREACH(f, &p->fq, entries)
		gen_strct_field(f);
	puts("};\n"
	     "");
}

/*
 * Generate the function declarations for a given structure.
 */
static void
gen_strct_funcs(const struct strct *p)
{
	int	 		 first;
	const struct search	*s;
	const struct sref	*sr;
	const struct sent	*sent;

	if (NULL != p->rowid)
		printf("/*\n"
		       " * Return the %s with rowid \"id\".\n"
		       " * Returns NULL if no object was found.\n"
		       " * Pointer must be freed with db_%s_free().\n"
		       " */\n"
		       "struct %s *db_%s_by_rowid"
			"(struct ksql *p, int64_t id);\n"
		       "\n",
		       p->name, p->name, p->name, p->name);

	printf("/*\n"
	       " * Call db_%s_unfill() and free \"p\".\n"
	       " * Has no effect if \"p\" is NULL.\n"
	       " */\n"
	       "void db_%s_free(struct %s *p);\n"
	       "\n",
	       p->name, p->name, p->name);

	printf("/*\n"
	       " * Fill in a %s from an open statement \"stmt\".\n"
	       " * This starts grabbing results from \"pos\",\n"
	       " * which may be NULL to start from zero.\n"
	       " * This recursively invokes the \"fill\" function\n"
	       " * for all nested structures.\n"
	       " */\n"
	       "void db_%s_fill(struct %s *p, "
		"struct ksqlstmt *stmt, size_t *pos);\n"
	       "\n",
	       p->name, p->name, p->name);

	printf("/*\n"
	       " * Free memory allocated by db_%s_fill().\n"
	       " * Also frees for all contained structures.\n"
	       " * Has not effect if \"p\" is NULL.\n"
	       " */\n"
	       "void db_%s_unfill(struct %s *p);\n"
	       "\n",
	       p->name, p->name, p->name);

	TAILQ_FOREACH(s, &p->sq, entries) {
		printf("/*\n"
		       " * Search for a specific %s.\n"
		       " * Uses the given fields in struct %s:\n",
		       p->name, p->name);
		TAILQ_FOREACH(sent, &s->sntq, entries) {
			printf(" * ");
			first = 1;
			TAILQ_FOREACH(sr, &sent->srq, entries) {
				putchar(first ? '\t' : '.');
				first = 0;
				printf("%s", sr->name);
			}
			sr = TAILQ_LAST(&sent->srq, srefq);
			printf(" (%s)\n", ftypes[sr->field->type]);
		}
		printf(" * Returns a pointer on success or NULL.\n"
		       " * Free the pointer with db_%s_free().\n"
		       " */\n", p->name);
		print_func_search(p, s, 1);
		puts(";\n"
		     "");
	}
}

void
gen_header(const struct strctq *q)
{
	const struct strct *p;

	printf("#ifndef DB_H\n"
	       "#define DB_H\n"
	       "\n"
	       "/*\n"
	       " * WARNING: automatically generated by kwebapp %s.\n"
	       " * DO NOT EDIT!\n"
	       " */\n"
	       "\n", 
	       VERSION);

	TAILQ_FOREACH(p, q, entries)
		gen_strct_structs(p);

	puts("__BEGIN_DECLS\n"
	     "");

	TAILQ_FOREACH(p, q, entries)
		gen_strct_funcs(p);

	puts("__END_DECLS\n"
	     "\n"
	     "#endif /* ! DB_H */");
}
