.\"	$OpenBSD: mdoc.template,v 1.15 2014/03/31 00:09:54 dlg Exp $
.\"
.\" Copyright (c) 2017 Kristaps Dzonsons <kristaps@bsd.lv>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: May 19 2017 $
.Dt KWEBAPP 1
.Os
.Sh NAME
.Nm kwebapp
.Nd create web application API and database layer
.Sh SYNOPSIS
.Nm kwebapp
.Op Fl CjJnsv
.Op Fl c Ar header
.Op Fl d Ar oldconfig
.Op Ar config
.Sh DESCRIPTION
The
.Nm
utility accepts a configuration file
.Ar config
.Pq defaulting to standard input
and creates source files:
.Bl -bullet
.It
C API to the database (see
.Fl C
and
.Fl c ) ;
and optionally, the API from data objects to JSON output and field input
validation functions (see
.Fl j
and
.Fl v )
.It
SQL defining the database itself (see
.Fl s )
.It
SQL defining the difference between configuration versions (painless
updating of database schema) (see
.Fl d )
.It
JavaScript for filling in DOM trees with data given by
.Fl j
(see
.Fl J )
.El
.Pp
These reduce the often-repeated code of serialising and de-serialising
structures from a database into a web application.
.Pp
By default, it generates the C header file
.Pq see Fl C
and requires generated output to be linked with
.Xr ksql 3
and optionally
.Xr kcgijson 3 .
Its arguments are as follows:
.Bl -tag -width Ds
.It Fl c Ar header
Create the
.Sx C source
file implementing the header file
.Ar header .
.It Fl d Ar oldconfig
Create the
.Sx SQL update
sequence that updates
.Ar oldconfig ,
a
.Xr kwebapp 5
file, with the new configuration.
.It Fl C
Create the
.Sx C header
file.
.It Fl j
Add JSON output functions.
This will also require linking to
.Xr kcgijson 3 .
.It Fl J
Create the
.Sx JavaScript
file for receiving JSON objects and filling in DOM elements.
.It Fl n
Parse only (dry-run).
.It Fl s
Create the full
.Sx SQL schema
file.
.It Fl v
Add field input validation functions.
This will also require linking to
.Xr kcgi 3 .
.It Ar config
A configuration file in the
.Xr kwebapp 5
format.
.El
.Pp
In all instances (except for
.Fl n ) ,
the generated file is produced on standard output.
See the
.Sx EXAMPLES
section for a full run-through of functionality.
.Ss C header
The C header file generated by
.Nm
lists all structures and functions defined by
.Ar config .
Sources including the header will also need
.In ksql.h
.Po
see
.Xr ksql 3
for details
.Pc
and
.In stdint.h .
If any of your structures call for lists (see the
.Cm list
keyword in
.Xr kwebapp 5 ) ,
you'll need the
.In sys/queue.h
header as well.
If
.Fl j
was specified, you'll also need
.In kcgijson.h
and
.In kcgi.h ,
with just the latter for
.Fl v
.Po
see
.Xr kcgijson 3
and
.Xr kcgi 3
for details
.Pc .
.Pp
For each structure object in
.Ar config ,
.Nm
generates a C
.Dq struct
by that name containing all typed fields.
Moreover, if any of the fields are defined with
.Cm null ,
an additional field of
.Va has_xxxx
is defined, where
.Dq xxxx
is the name of the field.
This field will be non-zero if the field was not null during access;
otherwise it will be zero.
.Pp
If there are any list statements on the object, the structure has
queue macros created for it as well.
If there are any iterator statements, the function callback types are
also generated.
.Pp
The following functions are then generated per structure, letting
.Dq foo
to be the name of a sample structure object:
.Bl -tag -width Ds
.It Fn db_foo_delete_xxxx
Run the named delete function
.Dq xxxx .
The delete functions are specified with
.Cm delete
statements.
The parameters passed to this function are
the fields that constrain which rows are deleted.
Parameters are only specified for operations for binary-operator
constraints, i.e., those not checking for null status.
.It Fn db_foo_delete_by_yy
Like
.Fn db_foo_delete_xxxx ,
but using an un-named delete statement constrained by
.Dq yy .
.It Fn db_foo_fill
Zero and fill in a pointer from an open database query.
This fills all nested structures as well.
.It Fn db_foo_free
Frees a pointer returned by a unique search function.
.It Fn db_foo_freeq
Frees a queue (and its members) created by a listing function.
This function is produced only if there are listing statements on a
given structure.
.It Fn db_foo_get_xxxx
If the structure object has any named searches, these are listed in
place of the
.Dq xxxx .
The function accepts variables for all binary-operator fields to check
(i.e., all except for those checking for null).
.It Fn db_foo_get_by__xxxx__yy_zz
Like
.Fn db_foo_get_xxxx ,
but for (possibly-nested) structures.
These are listed with a double-undescore preceding each search term, and
a single underscore separating nested fields.
In the given example,
.Dq xxxx
is a field in the given structure and
.Dq yy_zz
means a field
.Dq zz
in the nested structure
.Dq yy .
.It Fn db_foo_insert
Insert a row and return its identifier.
This accepts all native fields as parameters excluding
.Cm rowid ,
which is automatically set by the database.
If any fields are specified as
.Cm null ,
they are passed into this functions as pointers.
The null values must then be specified as
.Dv NULL
pointers.
.It Fn db_foo_iterate_xxxx
Like
.Fn db_foo_get_xxxx ,
but invoking a function callback within the active query for each
retrieved result.
.It Fn db_foo_iterate_by__xxxx__yy_zz
Like
.Fn db_foo_get_by__xxxx__yy_zz ,
but invoking a function callback for the retrieved results.
.It Fn db_foo_list_xxxx
Like
.Fn db_foo_get_xxxx ,
but producing a queue of responses.
.It Fn db_foo_list_by__xxxx__yy_zz
Like
.Fn db_foo_get_by__xxxx__yy_zz ,
but producing a queue of responses.
.It Fn db_foo_unfill
Release resources filled from a database query.
This frees all nested structures as well.
.It Fn db_foo_update_xxxx
Run the named update function
.Dq xxxx .
The update functions are specified with
.Cm update
statements.
The parameters passed to this function are first the fields to modify,
then the fields that constrain which rows are updated.
If any modified fields are specified as
.Cm null ,
they are passed into this functions as pointers.
Any null values must then be specified as
.Dv NULL
pointers.
Update fields are only specified for operations for binary-operator
constraints, i.e., those not checking for null status.
.It Fn db_foo_update_xx_by_yy
Like
.Fn db_foo_update_xxxx ,
but using an un-named update statement modifying
.Dq xx
constrained by
.Dq yy .
.El
.Pp
There are also several convenience functions for the database:
.Bl -tag -width Ds
.It Fn db_open
Open a database in
.Dq safe exit
mode as documented in
.Xr ksql 3 .
Also installs the default logging facilities.
.It Fn db_close
Closes a database opened by
.Fn db_open .
.El
.Pp
If the
.Fl j
flag was specified, JSON-specific functions are also generated for each
structure object.
If you use this flag, you'll need to link with
.Xr kcgijson 3 ,
as they use the
.Vt "struct kjsonreq"
for formatting JSON.
Given the same structure
.Dq foo ,
the following are generated:
.Bl -tag -width Ds
.It Fn json_foo_data
Enumerate only the fields of the structure in JSON dictionary format.
The key is the field name and the value is a string for text types,
decimal number for reals, integer for integers, and base64-encoded
string for blobs.
If a field is null, it is serialised as a null value.
Fields marked
.Cm noexport
are not included in the enumeration, nor are passwords.
.It Fn json_foo_obj
Print the entire structure as a key-value pair where the key is the
structure name and the value is an object consisting of
.Fn json_foo_data .
.El
.Pp
If the
.Fl v
flag was specified, field input validation functions are generated.
A full validation array is given for all fields, although these need not
be used by the calling application.
You'll need to link with
.Xr kcgi 3 .
Given the same structure
.Dq foo ,
the following are generated:
.Bl -tag -width Ds
.It Fn valid_foo_xxxx
Validate the field
.Dq xxxx
in the structure.
This should be used in place of raw validation functions such as
.Xr kvalid_int 3 .
The validation function will at least validate the type.
If limitation clauses are given to a field, those will also be emitted
within this function.
.Em Note :
structs are not validated.
.It Vt enum valid_keys
An enumeration of all fields that accept validators.
The enumeration entries are VALID_FOO_XXXX, where
.Dq XXXX
is the field name.
The last enumeration value is always
.Dv VALID__MAX .
.It Vt const struct kvalid valid_keys[VALID__MAX]
A validation array for
.Xr khttp_parse 3 .
This uses the
.Fn valid_foo_xxxx
functions as described above and names corresponding HTML form entries
as
.Dq foo-xxxx ,
where again,
.Dq xxxx
is the field name.
.El
.Pp
All of these are fully documented in the header file.
The structures are documented using the comments given in
.Ar config .
.Ss C source
A series of function definitions for the
.Sx C header .
This is internally documented to assist the reader.
.Ss SQL schema
Emits a series of
.Cm CREATE TABLE
SQL commands representing the objects in
.Ar config .
These encapsulate the foreign keys and all other required SQL
attributes.
.Ss SQL update
Emits a series of
.Cm CREATE TABLE
and
.Cm ALTER TABLE
SQL commands to update the configuration
.Ar oldconfig
to the new configuration
.Ar config .
.Pp
The configuration files are considered incompatible if they contain
destructive differences: dropped objects (structures or fields) or
different fields (types, references, attributes).
.Ss JavaScript
Emits a standards-compliant JavaScript file filling JSON output (with
.Fl j )
into a DOM tree, usually acquired from an AJAX request to the web
application.
(This process is not managed by
.Nm . )
.Pp
To use the interface, simply include the generated file as a script,
create objects given the JSON output of
.Fl j ,
and invoke the object's
.Fn fill
method with the DOM tree node.
Given a structure
.Dq foo
and an AJAX response
.Dq response ,
this might look like:
.Bd -literal -offset indent
var obj = JSON.parse(response);
var e = document.getElementById('foo');
new foo(obj).fill(e);
.Ed
.Pp
For each field in the structure, this method will operate on elements
under the element with id
.Dq foo
having classes as follows:
.Bl -tag -width Ds
.It Li foo-xxxx-text
Replaces the contents of the element with the field value.
This is only applicable for non-blob native types.
.It Li foo-has-xxxx
Remove the
.Dq hide
class if the object is null, otherwise add the
.Dq hide
class.
.It Li foo-no-xxxx
Add the
.Dq hide
class if the object is null, otherwise remove the
.Dq hide
class.
.It Li foo-xxxx-obj
For structures, creates and invokes the
.Fn fill
method on the nested structure at the given element and its descendents.
This is only applicable for structure types.
.El
.Pp
The JavaScript file is fully documented in the JSDoc format.
.\" The following requests should be uncommented and used where appropriate.
.\" .Sh CONTEXT
.\" For section 9 functions only.
.\" .Sh RETURN VALUES
.\" For sections 2, 3, and 9 function return values only.
.\" .Sh ENVIRONMENT
.\" For sections 1, 6, 7, and 8 only.
.\" .Sh FILES
.Sh EXIT STATUS
.\" For sections 1, 6, and 8 only.
.Ex -std
.Pp
In the case of
.Fl d ,
exiting >0 means that
.Ar oldconfig
and
.Ar config
are incompatible.
.Sh EXAMPLES
Given a data layer defined in
.Pa db.txt ,
the following produce all of the code necessary for a web application to
manipulate and output its data:
.Bd -literal  -offset indent
$ kwebapp -j -C db.txt >extern.h
$ kwebapp -j -c extern.h db.txt >db.c
.Ed
.Pp
Assuming a
.Xr kcgi 3
and
.Xr ksql 3
web application
.Pa main.c
that interfaces with
.Pa extern.h ,
the following compiles the application.
.Bd -literal -offset indent
cc -c -o db.o db.c
cc -c -o main.o main.c
cc -o cgi db.o main.o -lksql -lsqlite3 -lkcgijson -lkcgi -lz
.Ed
.Pp
The first two libraries are needed for the database component via
.Xr ksql 3
and its library dependencies;
the latter, for the JSON output component via
.Xr kcgijson 3 .
.\" .Sh DIAGNOSTICS
.\" For sections 1, 4, 6, 7, 8, and 9 printf/stderr messages only.
.\" .Sh ERRORS
.\" For sections 2, 3, 4, and 9 errno settings only.
.Sh SEE ALSO
.Xr kcgi 3 ,
.Xr kcgijson 3 ,
.Xr ksql 3 ,
.Xr kwebapp 5
.\" .Sh STANDARDS
.\" .Sh HISTORY
.\" .Sh AUTHORS
.\" .Sh CAVEATS
.\" .Sh BUGS
