/*
 * WARNING: automatically generated by ort-c-source 0.8.15.
 * DO NOT EDIT!
 */
#include <sys/queue.h>

#include <assert.h>
#include <stdio.h>
#include <stdint.h> /* int64_t */
#include <stdlib.h>
#include <string.h>
#include <time.h> /* _XOPEN_SOURCE and gmtime_r()*/
#include <unistd.h>

#include <sqlbox.h>

#include "db.h"

/*
 * All SQL statements we'll later define in "stmts".
 */
enum	stmt {
	STMT_foo_BY_UNIQUE_id,
	STMT_foo_BY_SEARCH_0,
	STMT__MAX
};

/*
 * Definition of our opaque "ort", which contains role information.
 */
struct	ort {
	/* Hidden database connection */
	struct sqlbox *db;
};

/*
 * Table columns.
 * The macro accepts a table name because we use AS statements a lot.
 * This is because tables can appear multiple times in a single query and 
 * need aliasing.
 */
#define DB_SCHEMA_foo(_x) \
	#_x ".hash" "," \
	#_x ".id"

/*
 * Our full set of SQL statements.
 * We define these beforehand because that's how sqlbox(3) handles 
 * statement generation.
 * Notice the "AS" part: this allows for multiple inner joins without 
 * ambiguity.
 */
static	const char *const stmts[STMT__MAX] = {
	/* STMT_foo_BY_UNIQUE_id */
	"SELECT " DB_SCHEMA_foo(foo) " FROM foo WHERE foo.id = ?",
	/* STMT_foo_BY_SEARCH_0 */
	"SELECT COUNT(*) FROM foo "
		"WHERE foo.hash = ?",
};

/*
 * Finally, all of the functions we'll use.
 * All of the non-static functions are documented in the associated 
 * header file.
 */

void
db_trans_open(struct ort *ctx, size_t id, int mode)
{
	struct sqlbox *db = ctx->db;
	int c;

	if (mode < 0)
		c = sqlbox_trans_exclusive(db, 0, id);
	else if (mode > 0)
		c = sqlbox_trans_immediate(db, 0, id);
	else
		c = sqlbox_trans_deferred(db, 0, id);
	if (!c)
		exit(EXIT_FAILURE);
}

void
db_trans_rollback(struct ort *ctx, size_t id)
{
	struct sqlbox *db = ctx->db;

	if (!sqlbox_trans_rollback(db, 0, id))
		exit(EXIT_FAILURE);
}

void
db_trans_commit(struct ort *ctx, size_t id)
{
	struct sqlbox *db = ctx->db;

	if (!sqlbox_trans_commit(db, 0, id))
		exit(EXIT_FAILURE);
}

void
db_logging_data(struct ort *ort, const void *arg, size_t sz)
{

	if (!sqlbox_msg_set_dat(ort->db, arg, sz))
		exit(EXIT_FAILURE);
}

struct ort *
db_open(const char *file)
{

	return db_open_logging(file, NULL, NULL, NULL);
}

struct ort *
db_open_logging(const char *file,
	void (*log)(const char *, void *),
	void (*log_short)(const char *, ...), void *log_arg)
{
	size_t i;
	struct ort *ctx = NULL;
	struct sqlbox_cfg cfg;
	struct sqlbox *db = NULL;
	struct sqlbox_pstmt pstmts[STMT__MAX];
	struct sqlbox_src srcs[1] = {
		{ .fname = (char *)file,
		  .mode = SQLBOX_SRC_RW }
	};

	memset(&cfg, 0, sizeof(struct sqlbox_cfg));
	cfg.msg.func = log;
	cfg.msg.func_short = log_short;
	cfg.msg.dat = log_arg;
	cfg.srcs.srcs = srcs;
	cfg.srcs.srcsz = 1;
	cfg.stmts.stmts = pstmts;
	cfg.stmts.stmtsz = STMT__MAX;

	for (i = 0; i < STMT__MAX; i++)
		pstmts[i].stmt = (char *)stmts[i];

	ctx = malloc(sizeof(struct ort));
	if (ctx == NULL)
		goto err;

	if ((db = sqlbox_alloc(&cfg)) == NULL)
		goto err;
	ctx->db = db;

	/*
	 * Now actually open the database.
	 * If this succeeds, then we're good to go.
	 */

	if (sqlbox_open_async(db, 0))
		return ctx;
err:
	sqlbox_free(db);
	free(ctx);
	return NULL;
}

void
db_close(struct ort *p)
{
	if (p == NULL)
		return;
	sqlbox_free(p->db);
	free(p);
}

/*
 * Fill in a foo from an open statement "stmt".
 * This starts grabbing results from "pos", which may be NULL to start 
 * from zero.
 * This follows DB_SCHEMA_foo's order for columns.
 */
static void
db_foo_fill(struct ort *ctx, struct foo *p, const struct sqlbox_parmset *set, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	memset(p, 0, sizeof(*p));
	if (sqlbox_parm_string_alloc
	    (&set->ps[(*pos)++], &p->hash, NULL) == -1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&set->ps[(*pos)++], &p->id) == -1)
		exit(EXIT_FAILURE);
}

static void
db_foo_fill_r(struct ort *ctx, struct foo *p,
	const struct sqlbox_parmset *res, size_t *pos)
{
	size_t i = 0;

	if (pos == NULL)
		pos = &i;
	db_foo_fill(ctx, p, res, pos);
}

/*
 * Free resources from "p" and all nested objects.
 * Does not free the "p" pointer itself.
 * Has no effect if "p" is NULL.
 */
static void
db_foo_unfill(struct foo *p)
{
	if (p == NULL)
		return;
	free(p->hash);
}

static void
db_foo_unfill_r(struct foo *p)
{
	if (p == NULL)
		return;
	db_foo_unfill(p);
}

void
db_foo_free(struct foo *p)
{
	db_foo_unfill_r(p);
	free(p);
}

uint64_t
db_foo_count_by_hash_streq(struct ort *ctx, const char *v1)
{
	const struct sqlbox_parmset *res;
	int64_t val;
	struct sqlbox *db = ctx->db;
	struct sqlbox_parm parms[1];

	parms[0].sparm = v1;
	parms[0].type = SQLBOX_PARM_STRING;

	if (!sqlbox_prepare_bind_async
	    (db, 0, STMT_foo_BY_SEARCH_0, 1, parms, 0))
		exit(EXIT_FAILURE);
	if ((res = sqlbox_step(db, 0)) == NULL)
		exit(EXIT_FAILURE);
	else if (res->psz != 1)
		exit(EXIT_FAILURE);
	if (sqlbox_parm_int(&res->ps[0], &val) == -1)
		exit(EXIT_FAILURE);
	sqlbox_finalise(db, 0);
	return (uint64_t)val;
}
